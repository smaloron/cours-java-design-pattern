# Introduction aux Design Patterns

## Objectifs Pédagogiques

À la fin de ce module, vous serez capable de :

* **Définir** ce qu'est un "Design Pattern" et ce qu'il n'est pas.
* **Expliquer** l'origine des patterns et l'importance du "Gang of Four".
* **Identifier** les bénéfices concrets de l'utilisation des patterns dans un projet.
* **Classifier** les patterns dans leurs trois grandes familles : Création, Structure et Comportement.
* **Comprendre** les bases de la notation UML pour lire et dessiner des diagrammes de classes.

## Introduction : Pourquoi s'intéresser aux Design Patterns ?

Imaginez que vous êtes un architecte. Allez-vous réinventer la manière de construire un mur porteur, une fenêtre ou un
escalier pour chaque nouvelle maison ? Probablement pas. Vous allez utiliser des solutions éprouvées, comprises par tous
les corps de métier, qui garantissent la solidité, la sécurité et l'efficacité de la construction.

En développement logiciel, c'est exactement la même idée ! Les **Design Patterns** (ou Patrons de Conception) sont des *
*solutions éprouvées à des problèmes de conception récurrents**.

Vous avez probablement déjà rencontré des situations complexes :

* Un code qui devient un véritable "plat de spaghettis", où tout est mélangé.
* L'ajout d'une petite fonctionnalité qui vous oblige à modifier des dizaines de fichiers.
* Des difficultés à expliquer la structure de votre code à un nouveau membre de l'équipe.

Les Design Patterns sont vos plans d'architecte. Ils vous fournissent un vocabulaire commun et des stratégies élégantes
pour construire des applications robustes, flexibles et faciles à maintenir. Ce cours est votre guide pour apprendre à
lire ces plans et à les utiliser pour devenir un meilleur concepteur d'applications.

## L'essentiel : Les Fondations

### Qu'est-ce qu'un Design Pattern ?

Un Design Pattern n'est pas un morceau de code que vous pouvez copier-coller. C'est une **description ou un modèle**
pour résoudre un problème dans un contexte particulier. Pensez-y comme une recette de cuisine :

* **Le Problème :** Vous avez faim et voulez un gâteau au chocolat (ex: vous devez créer des objets mais le type exact
  n'est connu qu'à l'exécution).
* **La Recette (le Pattern) :** Elle vous donne la liste des ingrédients (classes, interfaces), les étapes (méthodes à
  appeler) et le résultat attendu (un objet bien configuré, un code flexible).
* **Votre Implémentation :** Vous suivez la recette, mais vous pouvez choisir du chocolat noir ou au lait, ajouter des
  noix... Vous adaptez la recette à votre besoin précis.

<tip>
Un pattern est une solution formalisée et réutilisable. Ce n'est **ni un algorithme** (il décrit la structure, pas une suite d'opérations précises), **ni une bibliothèque** (c'est une idée, pas du code concret).
</tip>

### Une Brève Histoire : Le "Gang of Four" (GoF)

En 1994, quatre informaticiens de génie – Erich Gamma, Richard Helm, Ralph Johnson et John Vlissides – ont publié un
livre qui a tout changé : **"Design Patterns: Elements of Reusable Object-Oriented Software"**.

On les surnomme affectueusement le **"Gang of Four" (GoF)**.

Leur livre a catalogué 23 patterns fondamentaux, leur a donné un nom et a fourni un format standardisé pour les décrire.
En faisant cela, ils ont créé un **vocabulaire commun** essentiel pour les développeurs du monde entier. Dire "Ici, on
pourrait utiliser un Singleton" est bien plus rapide et précis que de décrire tout le mécanisme pendant 10 minutes.

### Les Bénéfices Concrets

Pourquoi devriez-vous investir du temps à apprendre ces patterns ?

* **Maintenabilité :** Un code structuré autour de patterns connus est plus facile à comprendre pour vous et pour les
  autres. Le faire évoluer devient moins risqué.
* **Flexibilité et Extensibilité :** Les patterns sont conçus pour découpler les composants de votre application.
  Ajouter une nouvelle fonctionnalité se fait souvent en ajoutant une nouvelle classe, sans modifier le code existant (
  le fameux Principe Ouvert/Fermé).
* **Réutilisabilité :** Les patterns sont des solutions qui ont fait leurs preuves dans d'innombrables projets. Vous
  bénéficiez de l'expérience de milliers de développeurs.
* **Communication :** Ils créent un langage commun au sein de votre équipe, ce qui rend les discussions sur
  l'architecture et la conception beaucoup plus efficaces.

### Les Trois Grandes Familles de Patterns

Le GoF a organisé les 23 patterns en trois catégories, selon leur intention. C'est une excellente manière de s'y
retrouver.

<tabs>
<tab title="Patterns de Création">
    <p><b>Leur rôle :</b> Gérer la création d'objets de manière contrôlée et flexible.</p>
    <p><b>La question à laquelle ils répondent :</b> "Comment, quand et quel objet doit être créé ?"</p>
    <p><b>Exemples :</b> Singleton, Factory, Builder, Prototype.</p>
    <p><b>Analogie :</b> C'est le service d'admission d'un hôpital. Il décide comment un nouveau patient (objet) est enregistré et assigné à une chambre, en fonction de son état.</p>
</tab>
<tab title="Patterns de Structure">
    <p><b>Leur rôle :</b> Organiser les classes et les objets pour former des structures plus grandes et plus complexes.</p>
    <p><b>La question à laquelle ils répondent :</b> "Comment assembler des objets pour qu'ils collaborent ?"</p>
    <p><b>Exemples :</b> Adapter, Decorator, Facade, Composite, Proxy.</p>
    <p><b>Analogie :</b> C'est l'agencement des pièces dans une maison. Comment le salon, la cuisine et les chambres sont-ils connectés pour former un tout cohérent ?</p>
</tab>
<tab title="Patterns Comportementaux">
    <p><b>Leur rôle :</b> Gérer les algorithmes et la répartition des responsabilités entre les objets.</p>
    <p><b>La question à laquelle ils répondent :</b> "Comment les objets communiquent-ils entre eux ?"</p>
    <p><b>Exemples :</b> Strategy, Observer, Command, Template Method, State.</p>
    <p><b>Analogie :</b> C'est le système de communication dans une tour de contrôle aérienne. Comment les messages sont-ils passés entre les pilotes et les contrôleurs pour éviter les collisions ?</p>
</tab>
</tabs>

## Pour aller plus loin : Introduction aux Principes S.O.L.I.D.

Les Design Patterns n'existent pas dans le vide. Ils sont souvent l'incarnation de principes de conception fondamentaux.
Les plus célèbres sont les principes **S.O.L.I.D.**, définis par Robert C. Martin ("Uncle Bob").

Comprendre ces principes vous aidera à saisir le "pourquoi" derrière la structure de nombreux patterns.

* **S - Single Responsibility Principle (Principe de responsabilité unique) :**
    * **Idée :** Une classe ne devrait avoir qu'une seule raison de changer.
    * **Pourquoi ?** Évite les classes "couteau suisse" qui font tout et qui sont fragiles au moindre changement.

* **O - Open/Closed Principle (Principe ouvert/fermé) :**
    * **Idée :** Une entité logicielle (classe, module, fonction) doit être ouverte à l'extension, mais fermée à la
      modification.
    * **Pourquoi ?** Pour pouvoir ajouter de nouvelles fonctionnalités sans toucher au code existant et testé, réduisant
      ainsi les risques de régression. C'est le cœur de nombreux patterns comme Strategy ou Decorator.

* **L - Liskov Substitution Principle (Principe de substitution de Liskov) :**
    * **Idée :** Une instance d'une classe enfant doit pouvoir remplacer une instance de sa classe parent sans altérer
      la cohérence du programme.
    * **Pourquoi ?** Garantit que votre héritage est correct et que le polymorphisme fonctionne comme prévu.

* **I - Interface Segregation Principle (Principe de ségrégation des interfaces) :**
    * **Idée :** Un client ne devrait pas être forcé de dépendre de méthodes qu'il n'utilise pas. Préférez plusieurs
      petites interfaces spécifiques à une seule grosse interface générale.
    * **Pourquoi ?** Rend le code plus léger et plus précis, en évitant les implémentations "vides" de méthodes
      inutiles.

* **D - Dependency Inversion Principle (Principe d'inversion des dépendances) :**
    * **Idée :** Les modules de haut niveau ne doivent pas dépendre des modules de bas niveau. Les deux doivent dépendre
      d'abstractions (interfaces).
    * **Pourquoi ?** C'est le secret du découplage ! Cela permet de changer une implémentation (ex: passer d'une base de
      données MySQL à PostgreSQL) sans impacter le reste de l'application. C'est la base de l'injection de dépendances
      et des patterns Factory.

<warning>
Ne vous inquiétez pas si tout n'est pas clair immédiatement. Considérez S.O.L.I.D. comme une boussole. Au fur et à mesure que nous explorerons les patterns, nous verrons comment ils appliquent brillamment ces principes.
</warning>

## Préparation du Projet "Fil Rouge"

Pour rendre l'apprentissage concret, nous allons travailler sur un projet fil rouge tout au long de ce cours : une
application de gestion de bibliothèque. Les exercices consisteront à améliorer son architecture en utilisant les
patterns que nous découvrirons.

Voici la structure de base du projet. Vous pouvez la mettre en place dans votre IDE préféré.

<tabs>
<tab title="pom.xml">
<p>Fichier de configuration Maven avec les dépendances nécessaires.</p>
<code-block lang="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;fr.formation.spring&lt;/groupId&gt;
    &lt;artifactId&gt;library-app&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;library-app&lt;/name&gt;
    &lt;description&gt;Projet fil rouge pour le cours de Design Patterns&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code-block>
</tab>
<tab title="application.properties">
<p>Configuration de la base de données en mémoire H2.</p>
<code-block lang="properties">
# Configuration du port du serveur
server.port=8080

# Configuration de la source de données H2

spring.datasource.url=jdbc:h2:mem:librarydb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password

# Configuration de JPA/Hibernate

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Activer la console H2

spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
</code-block>
</tab>
<tab title="Entités JPA">

<p>Créez un package <code>fr.formation.spring.app.entities</code>.</p>

**Book.java**

```java
package fr.formation.spring.app.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.Set;

@Entity
@Getter
@Setter
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title; // Titre du livre
    private String isbn;  // Numéro ISBN unique

    @ManyToOne(cascade = CascadeType.PERSIST)
    private Author author; // L'auteur du livre

    @ManyToMany(cascade = CascadeType.PERSIST)
    @JoinTable(
            name = "book_category",
            joinColumns = @JoinColumn(name = "book_id"),
            inverseJoinColumns = @JoinColumn(name = "category_id")
    )
    private Set<Category> categories; // Catégories du livre
}
```

**Author.java**

```java
package fr.formation.spring.app.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
public class Author {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name; // Nom complet de l'auteur
}
```

**Category.java**

```java
package fr.formation.spring.app.entities;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name; // Nom de la catégorie (ex: "Science-Fiction")
}
```

</tab>
<tab title="Repositories">
<p>Créez un package <code>fr.formation.spring.app.repositories</code>.</p>
<p>Ces interfaces permettent à Spring Data JPA de générer les requêtes pour nous.</p>

**BookRepository.java**

```java
package fr.formation.spring.app.repositories;

import fr.formation.spring.app.entities.Book;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface BookRepository extends JpaRepository<Book, Long> {
}
```

**AuthorRepository.java**

```java
package fr.formation.spring.app.repositories;

import fr.formation.spring.app.entities.Author;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface AuthorRepository extends JpaRepository<Author, Long> {
}
```

**CategoryRepository.java**

```java
package fr.formation.spring.app.repositories;

import fr.formation.spring.app.entities.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
}
```

</tab>
<tab title="Data Seeder">
<p>Créez une classe dans un package <code>fr.formation.spring.app.config</code> pour hydrater la base avec des données de test au démarrage.</p>

**DataInitializer.java**

```java
package fr.formation.spring.app.config;

import fr.formation.spring.app.entities.Author;
import fr.formation.spring.app.entities.Book;
import fr.formation.spring.app.entities.Category;
import fr.formation.spring.app.repositories.BookRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Set;

@Configuration
public class DataInitializer {

    @Bean
    public CommandLineRunner initDatabase(BookRepository bookRepository) {
        return args -> {
            // Catégories
            Category sf = new Category();
            sf.setName("Science-Fiction");

            Category fantasy = new Category();
            fantasy.setName("Fantasy");

            // Auteurs
            Author herbert = new Author();
            herbert.setName("Frank Herbert");

            Author tolkien = new Author();
            tolkien.setName("J.R.R. Tolkien");

            // Livres
            Book dune = new Book();
            dune.setTitle("Dune");
            dune.setIsbn("978-2266286260");
            dune.setAuthor(herbert);
            dune.setCategories(Set.of(sf));

            Book lotr = new Book();
            lotr.setTitle("The Lord of the Rings");
            lotr.setIsbn("978-0618640157");
            lotr.setAuthor(tolkien);
            lotr.setCategories(Set.of(fantasy));

            // Sauvegarde en cascade grâce à CascadeType.PERSIST
            bookRepository.save(dune);
            bookRepository.save(lotr);

            System.out.println("Database has been initialized with test data.");
        };
    }
}
```

</tab>
</tabs>

Une fois ce projet configuré, lancez votre application. Vous devriez voir dans la console le message
`Database has been initialized...` et pouvoir accéder à la console H2 sur `http://localhost:8080/h2-console` (utilisez
l'URL JDBC `jdbc:h2:mem:librarydb`).

## Exercice 1 : Analyse d'un "Code Smell"

Ce premier exercice n'implique pas d'écrire du code, mais d'aiguiser votre regard de concepteur. Dans notre
bibliothèque, nous devons pouvoir notifier les utilisateurs de différentes manières (email, SMS, notification push dans
une app mobile).

Voici une première implémentation "naïve" d'un service de notification.

```java
package fr.formation.spring.app.services;

// A NE PAS COPIER DANS LE PROJET, CECI EST UN EXEMPLE A ANALYSER
public class NotificationService {

    /**
     * Envoie une notification à un utilisateur.
     * @param user le nom de l'utilisateur
     * @param message le message à envoyer
     * @param type le type de notification ("EMAIL", "SMS", "PUSH")
     */
    public void sendNotification(String user, String message, String type) {
        if ("EMAIL".equalsIgnoreCase(type)) {
            // Logique pour configurer le serveur SMTP et envoyer un email
            System.out.println("--- ENVOI EMAIL ---");
            System.out.println("À: " + user + "@email.com");
            System.out.println("Message: " + message);
            System.out.println("--------------------");
        } else if ("SMS".equalsIgnoreCase(type)) {
            // Logique pour se connecter à une gateway SMS
            System.out.println("--- ENVOI SMS ---");
            System.out.println("Numéro: +33612345678 (pour " + user + ")");
            System.out.println("Message: " + message);
            System.out.println("-----------------");
        } else if ("PUSH".equalsIgnoreCase(type)) {
            // Logique pour se connecter à l'API Firebase/Apple Push
            System.out.println("--- NOTIFICATION PUSH ---");
            System.out.println("Device Token pour: " + user);
            System.out.println("Message: " + message);
            System.out.println("-------------------------");
        } else {
            System.out.println("Type de notification non supporté: " + type);
        }
    }
}

```

**Votre mission :**

1. Lisez attentivement ce code.
2. Quels sont, selon vous, les problèmes de conception de cette classe ?
3. Imaginez que demain, votre chef de projet vous demande d'ajouter un nouveau type de notification : "Slack". Quelles
   modifications devriez-vous faire ? Est-ce que cela vous semble optimal ?
4. Sans encore connaître les patterns, comment essaieriez-vous intuitivement d'améliorer ce code pour le rendre plus
   flexible et plus facile à maintenir ?

### Correction exercice 1 {collapsible="true"}

Excellente analyse ! Voici les points clés que vous avez probablement identifiés.

1. **Problèmes de conception :**
    * **Violation du Principe de Responsabilité Unique (S de SOLID) :** La classe `NotificationService` gère à la fois
      la logique de "sélection" du canal et la logique d'implémentation de *chaque* canal. Elle a plusieurs raisons de
      changer.
    * **Violation du Principe Ouvert/Fermé (O de SOLID) :** La classe est **fermée à l'extension** (on ne peut pas
      ajouter un nouveau type sans la modifier) et **ouverte à la modification** (on doit éditer son code source pour
      tout changement). C'est l'exact opposé du principe.
    * **Mauvaise maintenabilité :** La structure `if-else if` va grandir indéfiniment avec chaque nouveau type de
      notification, rendant la méthode `sendNotification` de plus en plus complexe et difficile à lire.
    * **Fragilité :** Une erreur dans la logique d'un type de notification (ex: une faute de frappe dans le `if`) peut
      impacter tous les autres.
    * **Difficulté à tester :** Tester unitairement la logique d'envoi de SMS est difficile car elle est noyée au milieu
      des autres logiques.

2. **Ajout de la notification "Slack" :**
    * Il faudrait ajouter un nouveau bloc `else if ("SLACK".equalsIgnoreCase(type)) { ... }` dans la méthode
      `sendNotification`.
    * Cela implique de **modifier une classe existante et déjà en production**, ce qui est risqué. Ce n'est absolument
      pas optimal.

3. **Pistes d'amélioration intuitive :**
    * L'idée serait de **séparer les responsabilités**. On pourrait avoir une "chose" par type de notification.
    * Par exemple, créer des classes distinctes : `EmailNotifier`, `SmsNotifier`, `PushNotifier`.
    * Ces classes pourraient toutes partager une méthode commune, comme `send(user, message)`. On pourrait les faire
      implémenter une interface commune, par exemple `Notifier`.
    * Le `NotificationService` n'aurait plus qu'à choisir la bonne classe (`EmailNotifier`, `SmsNotifier`...) et à
      appeler sa méthode `send`.

Si vous êtes arrivé à cette conclusion, félicitations ! Vous venez de "réinventer" l'essence de deux des plus importants
patterns que nous allons étudier : **Factory Method** (pour créer le bon notificateur) et **Strategy** (pour utiliser
l'algorithme d'envoi interchangeable).

## Auto-évaluation

Testez vos connaissances sur ce premier chapitre. Ne vous inquiétez pas, l'objectif est de vous aider à consolider ce
que vous avez appris.

<warning>
Les corrections de cette auto-évaluation se trouvent à la fin de l'ensemble du support de cours pour ne pas vous tenter !
</warning>

**Questions à Choix Multiple (QCM)**

1. Quelle est la définition la plus précise d'un Design Pattern ?
    * a) Un morceau de code réutilisable que l'on peut copier-coller.
    * b) Une bibliothèque open-source qui résout des problèmes courants.
    * c) Un plan ou une description d'une solution éprouvée à un problème de conception récurrent.
    * d) Un algorithme spécifique pour trier des données.

2. Lequel de ces patterns appartient à la catégorie des **Patterns de Création** ?
    * a) Adapter
    * b) Observer
    * c) Facade
    * d) Builder

3. Quel principe S.O.L.I.D. est le plus directement violé par une classe qui gère la connexion à la base de données, la
   logique métier ET l'affichage HTML ?
    * a) Open/Closed Principle
    * b) Single Responsibility Principle
    * c) Liskov Substitution Principle
    * d) Dependency Inversion Principle

4. Dans un diagramme de classes UML, quel symbole représente une relation de **Composition** ?
    * a) Une flèche simple `-->`
    * b) Une ligne avec un losange vide `<>--`
    * c) Une ligne avec un losange plein `<*>--`
    * d) Une flèche en pointillé avec un triangle `..|>`

**Questions Ouvertes**

5. Expliquez avec vos propres mots pourquoi le fait d'avoir un "vocabulaire commun" grâce aux patterns est un avantage
   majeur pour une équipe de développement.
6. Quelle est la différence fondamentale entre le **Principe Ouvert/Fermé** et le **Principe de Responsabilité Unique
   ** ?

## Conclusion

Félicitations, vous avez franchi la première étape ! Vous comprenez maintenant ce qu'est un Design Pattern, d'où il
vient, et pourquoi il est si crucial dans la carrière d'un concepteur développeur d'applications.

Vous avez découvert :

* Que les patterns sont des **recettes de conception**, pas du code prêt à l'emploi.
* Qu'ils sont classés en **trois grandes familles** (Création, Structure, Comportement) qui nous aident à nous orienter.
* Qu'ils s'appuient sur des **principes de conception solides** (S.O.L.I.D.) qui visent à créer du code de haute
  qualité.
* Comment lire les **diagrammes UML** qui nous serviront de carte tout au long de ce voyage.

Nous avons posé les fondations. Dans le prochain chapitre, nous allons commencer à construire notre édifice en explorant
la première famille : les **Patterns de Création**. Préparez-vous à devenir un maître dans l'art de créer des objets de
manière élégante et flexible 